// import hoistStatics from 'hoist-non-react-statics'
// import invariant from 'invariant'
import { Component, createElement } from 'react'

import Subscription from '../utils/Subscription'
import { storeShape, subscriptionShape } from '../utils/PropTypes'

const dummyState = {}
function noop() {}

function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  const selector = {
    run: function (props) {
      //when it runs, it will call the sourceSelector to calculate the next mergedProps
      const nextProps = sourceSelector(store.getState(), props);
      //but it only update the React Component if it is a different props
      if (nextProps !== selector.props) {
        //update for React
        selector.shouldComponentUpdate = true;
        selector.props = nextProps;
      }
    }
  }
  return selector
}



export default function connectAdvanced(
  /*
    Source Code Comments:
    Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
    props. Do not use connectAdvanced directly without memoizing results between calls to your
    selector, otherwise the Connect component will re-render on every state or props change.
  */
  selectorFactory,
  mapToProps
) {
  //the context for itself
  const contextTypes = {
    store : storeShape,
    parentSub : subscriptionShape,
  }
  //override context subscriptionKey for child
  const childContextTypes = {
    parentSub: subscriptionShape,
  }

  //wrapWithConnect is the HOC
  return function wrapWithConnect(WrappedComponent) {
    //Connect is the 'Container' Component
    class Connect extends Component {
      constructor(props, context) {
        super(props, context)
        this.state = {}
        this.store = context.store
        //init the selector, initialize the initial mergedProps from the state of the store 
        this.initSelector()
        //but since it hasn't subscribe it wont trigger any callback
        this.initSubscription()
        console.log(this.subscription);
      }

      //https://facebook.github.io/react/docs/context.html#updating-context
      //https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076
      getChildContext() {
        //override subscription context variable for the child
        return {
          parentSub : this.subscription
        }

      }

      componentDidMount() {
        console.log('did mount', this.props)
        this.subscription.trySubscribe()
      }

      componentWillReceiveProps(nextProps) {
        console.log('componentWillReceiveProps')
        //one of the source of data for the container component (props from parent)
        this.selector.run(nextProps)
      }

      shouldComponentUpdate() {
        //this is the React.Component.shouldComponentUpdate
        //it is fully depends on the flag on the selector which is optimized
        //without the optimization, the component will re-render on  on every state or props change 
        return this.selector.shouldComponentUpdate
      }

      componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe()
        this.subscription = null
        this.notifyNestedSubs = noop
        this.store = null
        this.selector.run = noop
        this.selector.shouldComponentUpdate = false
      }


      initSelector() {
        //sourceSelector is a function that can 'select/get' the desired props to be injected to the wrappedComponent
        //sourceSelector: (reduxStore.state + ownProps) => injected mergedProps 
        const sourceSelector = selectorFactory(this.store.dispatch, mapToProps)
        this.selector = makeSelectorStateful(sourceSelector, this.store)

        //run the selector to initialize the initial mergedProps
        this.selector.run(this.props)
      }

      initSubscription() {
        const parentSub = this.context.parentSub //for the root it is none
        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))
      }

      onStateChange() {
        //one of the source of truth (redux store)
        //run the selector with ownProps to update the selector when state change
        this.selector.run(this.props)

        if (!this.selector.shouldComponentUpdate) {
          console.log('注意咯 我们并没有更新')
          //if it should not updated, notify the sub component listeners directly
          //by calling the its'subscription notifyNestedSubs method
          this.subscription.notifyNestedSubs()
        } else {
          console.log('小弟')
          // if it should update, before reset State by setState()
          // override lifecyle method componentDidUpdate
          // after it is render and updated, notifyNestedSubs
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
          //use a dummy state to re-render
          this.setState(dummyState)
        }
      }
      componentDidUpdate() {
        console.log('component Did Update', this.selector.shouldComponentUpdate);
      }



      notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidMount` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        // disable the override lifecyle method
        this.componentDidUpdate = undefined
        this.subscription.notifyNestedSubs()
      }

      render() {
        const selector = this.selector
        selector.shouldComponentUpdate = false
        return createElement(WrappedComponent, selector.props)
      }
    }
    //for passing context to child
    Connect.childContextTypes = childContextTypes
    //for receiving context from parent
    Connect.contextTypes = contextTypes
    return Connect;
  }
}


