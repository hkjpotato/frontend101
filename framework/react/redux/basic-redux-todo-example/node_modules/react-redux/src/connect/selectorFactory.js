import shallowEqual from '../utils/shallowEqual'
function strictEqual(a, b) { return a === b }
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  //use spread operator to match to new object
  return { ...ownProps, ...stateProps, ...dispatchProps }
}

//a factory function that generate the sourceSelector
export default function selectorFactory(dispatch, 
{
  mapStateToProps,
  mapDispatchToProps,
  mergeProps = defaultMergeProps,
}) {
  //the store state
  let state
  //container's own props
  let ownProps
  //derived props from the state (and maybe with ownProps)
  let stateProps
  //derived props from the store.dispatch (and maybe with ownProps)
  let dispatchProps
  //the return merged props(stateProps + dispatchProps + ownProps) to be injected to wrappedComponent
  let mergedProps

  // the source selector is memorizable.
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    //before running the actual mapping function, compare its arguments with the previous one
    const propsChanged = !shallowEqual(nextOwnProps, ownProps)
    const stateChanged = !strictEqual(nextState, state)
    //update state and ownProps
    state = nextState
    ownProps = nextOwnProps
 
    //calculate the return merged props based on different cases
    // 1.differentiate different cases because we want to minimize the call of mapping function
    // 2.the mapping function itself can be optimized by Reselect, but it is not the concern here

    //case 1: both state in redux and own props change
    if (propsChanged && stateChanged) {
      //derive new props based on state
      stateProps = mapStateToProps(state, ownProps)
      //since the ownProps change, update dispatch callback if it depends on props
      if (mapDispatchToProps.length !== 1) dispatchProps = mapDispatchToProps(dispatch, ownProps)
      //merge the props
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
      return mergedProps
    }
    //case 2: only own props changes
    if (propsChanged) {
      //only update stateProps and dispatchProps if they rely on ownProps
      if (mapStateToProps.length !== 1) stateProps = mapStateToProps(state, ownProps) //it just call the mapping function
      if (mapDispatchToProps.length !== 1) dispatchProps = mapDispatchToProps(dispatch, ownProps)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
      return mergedProps
    }
    //case 3: only store state changes
    // 1.since stateProps depends on state so must run mapping again
    // 2.for dispatch, since store.dispatch and ownProps remain the same, no need to update
    if (stateChanged) {
      const nextStateProps = mapStateToProps(state, ownProps)
      const statePropsChanged = !shallowEqual(nextStateProps, stateProps)
      stateProps = nextStateProps
      //if stateProps changed, update mergeProps
      if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
      return mergedProps
    }

    //case 4: no change, no need to call the mapping function and return last result directly
    if (!propsChanged && !stateChanged) {
      return mergedProps; //return last result if no change in input
    }
  }
}
