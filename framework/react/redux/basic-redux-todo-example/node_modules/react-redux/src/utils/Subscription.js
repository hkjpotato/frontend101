// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants
const nullListeners = { notify() {} }

//unfortunately, this is another core
//I really have no idea how the nested subscription work
//first, why order is important
function createListenerCollection() {
  let listeners = [];
  return {
    notify() {
      for(var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    subscribe(listener) {
      listeners.push(listener);
      return function unsubscribe() {
        listeners = listeners.filter(function(l) {return l !== listener;});
      }
    }
  }
}
//Subscription is a class
export default class Subscription {
  constructor(store, parentSub, onStateChange) {
    this.store = store
    this.parentSub = parentSub
    this.onStateChange = onStateChange
    // this.unsubscribe = null
    this.subscribed = false
    this.listeners = []
  }
  //api method for adding nested subscription listener to itself
  addNestedSub(listener) {
    //first, ensure itself has been subscribed, that's how the order is maintained
    this.trySubscribe()
    //THEN, subscribe the nested listener to its own listener collection
    // this.listeners.subscribe(listener)
    this.listeners.push(listener)
  }

  notifyNestedSubs() {
    this.listeners.forEach(l=>l());
  }


  trySubscribe() {
    //if not yet subscribed
    if (!this.subscribed) {
      //if has parentSub(from context), subscribe to parentSub
      if (this.parentSub !== null) this.parentSub.addNestedSub(this.onStateChange)
      //if root component, subscribe directly to store
      else this.store.subscribe(this.onStateChange)
      //mark it as subscribed
      this.subscribed = true;
      // this.listeners = createListenerCollection()
    }
  }

  /*
  How to maintain the order from top to bottom?

  subscribe trigger from child container mounted first
  ->child.trySub
    ->child has parentSub
    ->parentSub.addNestedSub(child's listener)
      ->parent.trySub
        ->parent has no parentSub
        ->store.subscribe(parent's listener) ...happen first
        ->parentSub create listenersCollection
      ->parent.listenersCollections subscribe (child'slistener)...happen second
    ->childSub create listenersCollection

  when parent container mounted, parent already subscribe

  thus only one onStateChange(from root component) will subscribe to the store directly
  
  store change will call the root listener(parent's onStateChange)

  in parent's onStateChange, it will 
  1. notify the nested listeners(child onStateChange) if not shouldComponentUpdate(thus it does not trigger re-render)
  
  */

  // tryUnsubscribe() {
  //   if (this.unsubscribe) {
  //     this.unsubscribe()
  //     this.unsubscribe = null
  //     this.listeners.clear()
  //     this.listeners = nullListeners
  //   }
  // }
}
