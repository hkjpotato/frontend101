<html>
    <button id="updateBtn">Update DataStore</button>
    <div id="app"></div>

    <!-- babel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.js"></script>
    <!-- react -->
    <script src="https://unpkg.com/react@15/dist/react.js"></script>
    <!-- react-dom -->
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.js"></script>


    <script>
    function getDataStore() {
      let comments = [];
      //init 10 comments
      let numOfcomments = 10;
      while (numOfcomments--) {
        comments.push({
          id: (10 - numOfcomments),
          text: 'comment ' + (10 - numOfcomments)
        });
      }

      let blogposts = [];
      //init 5 blogpost
      let numOfblogposts = 5;
      while (numOfblogposts--) {
        blogposts.push('blogpost ' + (5 - numOfblogposts));
      }
      //listeners list
      let listeners = [];
      //udpate function
      function update() {
        //add another comment
        comments = [
          ...comments, 
          {
            id: comments.length + 1,
            text: 'comment ' + (comments.length + 1)
          }
        ]; //dont immutable it since everything is in frontend.

        //update the blogposts content
        blogposts = blogposts.map((b) => {
          return b + (' update at min: ' + new Date().getMinutes().toString());
        });
        //notify the listeners
        listeners.forEach(l=>l());
      }

      function addChangeListener(listener) {
        listeners.push(listener);
      }

      function removeChangeListener(listener) {
        listeners = listeners.filter(l => l !== listener);
      }

      function getBlogPost(postId) {
        return blogposts[postId];
      }

      function getComments() {
        return comments;
      }

      return {
        getComments,
        getBlogPost,
        addChangeListener,
        removeChangeListener,
        update
      }
    }
    //my DataStore
    const DataStore = getDataStore();

    //function called by clicking on button
    function updateDataStore() {
      DataStore.update();
      console.log(DataStore.getComments());
      console.log(DataStore.getBlogPost(1));
    }

    document.getElementById('updateBtn').addEventListener('click', updateDataStore);
    </script>

    <script type="text/babel">
    //let's be very careful about the relationship between higher order component and higher order function and function composition and mixins

    //HOF : fn =(fn1) => fn2 //fn is higher order function
    //e.g. _.curry, _.compose

    //HOC: const EnhancedComponent = higherOrderComponent(WrappedComponent);
    //ATTENTION, this formula is not really correct
    //HOC require more than WrappedComponent as input
    //Unless, HOC is partial implemented or even hard coded
    //e.g. redux.connect and the withSubscription

    //is that ok to say WrappedComponent is the presentational component while the EnhancedComponent is the container component

    //OR, the higherOrderComponent is the container component?

    //As we know, the container component often generated by HOC

    //In that case, is wrappedComponent the argument of HOC

    //What about the other arguments?

    //We can write a function that creates components, like CommentList and BlogPost, that subscribe to DataStore. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let's call the function withSubscription:

    //!!!!!It seems that withSubscription is the HOC, and it accept wrappedComponent as the input


    //Note that an HOC doesn't modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC composes the original component by wrapping it in a container component. An HOC is a pure function with zero side-effects.


    //anyway let's write the most basic one
    class CommentList_Naive extends React.Component {
      constructor() {
        super();
        this.handleChange = this.handleChange.bind(this);
        this.state = {
          comments: DataStore.getComments() //dependency
        };
      }
      componentDidMount() {
        DataStore.addChangeListener(this.handleChange); //dependency
      }
      componentWillUnmount() {
        DataStore.removeChangeListener(this.handleChange); //dependency
      }
      handleChange() {
        this.setState({
          comments: DataStore.getComments() //dependency
        })
      }
      render() {
        return (
          <div>
          {
            this.state.comments.map((c) => (
              <div key={c.id}>{c.text}</div>
            ))
          }
          </div>
        )
      }
    }

    // ReactDOM.render(<CommentList_Naive />, document.getElementById('app'));



    //using mixin, the mixin factory
    //the mixin factory is a way to convert certain behavior into react lifecycle method here
    function StoreMixin(...stores) {
      var Mixin = {
        getInitialState() {
          let state =  this.getStateFromStores(this.props) //mixin depends on component
          // console.log(state)
          return state;
        },
        componentDidMount() {
          stores.forEach(store=>
            store.addChangeListener(this.handleStoresChanged)
          );
        },
        componentWillUnmount() {
          stores.forEach(store=>
            store.removeChangeListener(this.handleStoresChanged)
          );
        },
        handleStoresChanged() {
          this.setState(this.getStateFromStores) //mixin depends on component
        }
      }
      return Mixin;
    }


    const DataStoreMixin = StoreMixin(DataStore)

    const CommentList_Mixin = React.createClass({
      mixins: [DataStoreMixin],
      getStateFromStores(props) {
        //a component method, implicit depended by Mixin
        return {
          comments: DataStore.getComments()
        }
      },
      render() {
        return (
          <div>
          {
            this.state.comments.map((c) => (
              <div key={c.id}>{c.text}</div>
            ))
          }
          </div>
        )
      }
    });

    // ReactDOM.render(<CommentList_Mixin />, document.getElementById('app'));


    //think about 'pure functional mixin'
    //the basic idea is to use extend to inheritance parent's behaviors
    //while use mixin to addon mixin behavior
    //mixin still stands alone
    //original component is not affected
    // const CommentList_Pure = (props) => (
    //   <div>
    //   {
    //     props.comments.map(c => <div key={c.id}>{c.text}</div>)
    //   }
    //   </div>
    // )

    const CommentList_Pure = (props) => {
      console.log('hi', props);
      return (<div>
      {
        props.comments.map(c => <div key={c.id}>{c.text}</div>)
      }
      </div>)
    }


    //in react, no inheritance but component composition is used
    class CommentList_Container extends React.Component {
      constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.state = {
          comments: DataStore.getComments() //dependency
        };
      }
      componentDidMount() {
        DataStore.addChangeListener(this.handleChange); //dependency
      }
      componentWillUnmount() {
        DataStore.removeChangeListener(this.handleChange); //dependency
      }
      handleChange() {
        this.setState({
          comments: DataStore.getComments() //dependency
        })
      }
      render() {
        return <CommentList_Pure comments={this.state.comments} />
      }
    }

    // ReactDOM.render(<CommentList_Container />, document.getElementById('app'));

    /*------encapsulate the behavior of container pattern-----*/





    //Approach1
    function ComposeWithClass(clazz, mixin) {
      const subclazz = class extends clazz {};
      Object.assign(subclazz.prototype, mixin);
      return subclazz;
    }

    //myTry
    function ComposeWithContainer(Presentational, ...mixins) {
      const Container = React.createClass({
        mixins: mixins,
        render() {
          return React.createElement(
            Presentational,
            this.state,
            null
          );
        }
      });
      //similar to using empty extend class
      return Container;
    }
    //有点像自带餐具的早餐
    const DataStoreCommentMixin = Object.assign(DataStoreMixin, {
      getStateFromStores () {
        return {
          comments: DataStore.getComments() //这不漂亮，有个global的
        }
      }
    });

    const ComposedContainer = ComposeWithContainer(
      CommentList_Pure,
      DataStoreCommentMixin
    )


    // ReactDOM.render(<ComposedContainer />, document.getElementById('app'));


    //aproach #2, another form of HOC with mixin pattern
    //tool 是那个餐具
    //tool (store, self.props) => data
    //tool is the getStateFromStores
    function UseDataStore(WrappedComponent, tool) {
      return class extends React.Component {
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this); //event listener
          this.state = {
            data: tool(DataStore, props)
          };
        }
        componentDidMount() {
          DataStore.addChangeListener(this.handleChange);
        }
        handleChange() {
          this.setState({
            data: tool(DataStore, this.props)
          })
        }
       render() {
          // ... and renders the wrapped component with the fresh data!
          // Notice that we pass through any additional props
          return <WrappedComponent data={this.state.data} {...this.props} />;
        }
      }
    }

    const CommentList_Pure2 = (props) => {
      console.log('hi', props);
      return (<div>
      {
        props.data.map(c => <div key={c.id}>{c.text}</div>)
      }
      </div>)
    }

    const EnhancedComponent = UseDataStore(
      CommentList_Pure2,
      (DataStore, props) => DataStore.getComments()
    )

    // ReactDOM.render(<EnhancedComponent hkj="huang" />, document.getElementById('app'));



    //*-------GO INTO HOC & HOF--------*//
    function Apple(WrappedComponent) {
      class Apple extends React.Component {
        componentWillMount() {
          console.log('apple will mount!', this.props);
        }
        render() {
          return <WrappedComponent {...this.props} />;
        }
      }
      Apple.displayName ='CaoniMabi';
      return Apple;
    }

    function Pear(WrappedComponent) {
      class Pear extends React.Component {
        componentWillMount() {
          console.log('pear will mount!', this.props);
        }
        render() {
          console.log(WrappedComponent.displayName)
          // Filter out extra props that are specific to this HOC and shouldn't be
          // passed through
          const {extraProp, ...passThroughProps} = this.props;
          console.log('really?', extraProp, passThroughProps);
          // Inject props into the wrapped component. These are usually state values or
          // instance methods.
          const injectedProp = {data: 1000};
          // const injectedProp = someStateOrInstanceMethod
          //actually, the 'data' attribute is an injectedProp for CommentList_Pure2

          // Pass props to wrapped component
          return <WrappedComponent 
                    injectedProp={injectedProp}
                    {...passThroughProps}/>;
        }
      }
      Pear.displayName = `Pear(${WrappedComponent.displayName})`;
      return Pear
    }

    function MyPure(props) {
      console.log(props);
      return (
        <div>
          <p>{props.name}</p>
          <p>{props.age}</p>
          <p>{props.job}</p>
        </div>
      )
    }

    const Special = Pear(Apple(MyPure))
// HOCs add features to a component. They shouldn't drastically alter its contract. It's expected that the component returned from an HOC has a similar interface to the wrapped component.

// HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:

//Usually, HOCs accept additional arguments. 

//HOC(a, b, c) which is not good for functional composition
//we need to use partical application/curry to reduce  HOC(multi)=>HOC(single)

//HOC(multi)=>HOC(single), ok a HOF can do this, like curry



    // ReactDOM.render(<Special hehe={'this is extra'} name="huang" />, document.getElementById('app'));

    //The difference between HOF and HOC

    function ConnectToStoreBy(getStateFromStore, WrappedComponent) {
      //return a container
      class Container extends React.Component {
        constructor(props) {
          super(props);

          const data = getStateFromStore();
          console.log('test', data);
          this.state = {
            data: data
          }

          this.handleChange = this.handleChange.bind(this);
        }
        componentDidMount() {
          DataStore.addChangeListener(this.handleChange);
        }
        handleChange() {
          this.setState({
            data: getStateFromStore()
          })
        }
        proc(wrappedComponentInstance) {
          console.log(wrappedComponentInstance);
          console.log('should be a dom');
          console.log(this.refs);

        }
        render() {
          console.log('注意了');
          console.log(...this.props);
          return <WrappedComponent data={this.state.data} {...this.props} ref={this.proc.bind(this)} />
        }
      }
      return Container;
    }

    const NewContainer = ConnectToStoreBy(CommentList_Pure2, ()=>DataStore.getComments());

    //curried/partial application of the ConnectToStore so that it can return a HOC in forms of (c)=>(c)

    //HOF
    // const Connect = function(...args) {
    //   console.log('By Connect ', args);
    //   return (WrappedComponent) => ConnectToStoreBy.call(null, WrappedComponent, ...args);
    // }


    // const Unary = Connect(()=>DataStore.getComments());

    function compose(...fns) {
      return (args) => fns.reduceRight((v, fn)=>fn(v), args);
    }

    function curry(fn, ...args) {
      const numsOfArgs = fn.length;
      if (args.length === numsOfArgs) {
        return fn.apply(null, args);
      } else {
        return curry.bind(null, fn, ...args);
      }
    }



    // const NewContainer2 = Unary(CommentList_Pure2);


    // const NewContainer3 = compose(
    //   Pear,
    //   Connect(()=>DataStore.getComments())
    // )(CommentList_Pure2)


    //in other world, connect is a curried/partial application of the connectToBy method

    //meanwhile, connect is a HOF (curry produce HOF) that generate the Unary function, HOC.



    const CurriedConnectToStoreBy = curry(ConnectToStoreBy);


    const NewContainer4 = compose(
      Apple,
      CurriedConnectToStoreBy(()=>DataStore.getComments())
    )(CommentList_Pure2)
    // ReactDOM.render(<NewContainer4 hehe={'this is extra'} />, document.getElementById('app'));


    class Test2 extends React.Component {
      // componentDidMount() {
      //   console.log(this.refs);
      //   console.log(this.momo);
      // }
      proc(instance) {
        console.log(instance);
        console.log(this);
      }
      render() {
        return <div ref={this.proc}>hello</div>
      }
    }

    ReactDOM.render(<Test2 hehe={'this is extra'} />, document.getElementById('app'));
 

    </script>

</html>